use std::{error::Error, fs::File, io::Read};

#[derive(Clone, Copy, PartialEq)]
pub enum EnvironmentCell {
    Empty,
    Occupied(usize),
    BeamEntry,
    Splitter
}

impl EnvironmentCell {
    pub fn new(ch:char) -> Result<Self, Box<dyn Error>> {
        match ch {
            '.'=>Ok(Self::Empty),
            '|'=>Ok(Self::Occupied),
            'S'=>Ok(Self::BeamEntry),
            '^'=>Ok(Self::Splitter),
            _=>Err(format!("invalid symbol {}", ch).into())
        }
    }
    pub fn to_char(&self) -> char {
        match self {
            Self::Empty=>'.',
            Self::Occupied=>'|',
            Self::BeamEntry=>'S',
            Self::Splitter=>'^'
        }
    }
}

pub struct Environment {
    space: Vec<Vec<EnvironmentCell>>,
    pub split_count: usize,
    pub timeline_count: usize,
}

impl Environment {
    /**
     * Parse a new Environment object from string 
     * */
    pub fn from_string(input:&str) -> Result<Environment, Box<dyn Error>> {
        let space:Result<Vec<Vec<EnvironmentCell>>, Box<dyn Error>> = input.split("\n").into_iter()
            .filter(|line| line.len()>2)    //drop empty or nonsensically short lines
            .map(|line| {
                line.chars().map(|ch| EnvironmentCell::new(ch)).collect()
            })
            .collect();

        //Sanity check, so our assumptions during propagation hold
        match space.as_ref().map(|s| s.split_first()) {
            Ok(Some((first_line, others)))=>{
                let target_len = first_line.len();
                if others.iter().any(|line| line.len()!=target_len) {
                    return Err("at least one line had non-equal spacing".into())
                }
            },
            _=> { }
        }
        space.map(|space| Environment { space, split_count: 0, timeline_count: 0 })
    }

    /**
     * For debugging, presents a string representation of the Environment
     */
    pub fn to_string(&self) -> String {
        let s:Vec<String> = self.space.iter().map(|line| {
            String::from_iter(line.iter().map(|cell| cell.to_char()))
        }).collect();
        s.join("\n")
    }

    pub fn width(&self) -> usize {
        self.space.first().map(|line| line.len()).unwrap_or(0)
    }

    /**
     * Mutates the space, representing propagation from (row) to (row+1)
     */
    pub fn propagate(&mut self, row:usize) -> Result<(), Box<dyn Error>> {
        if row >= self.space.len()-1 {
            return Err(format!("row {} is out of range", row).into())
        }

        //We already know that all the rows are equal length, as this is ensured in the parsing method
        for col in 0..self.space[row].len() {
            match self.space[row][col] {
                //Inject a new beam is logically the same as propagating an existing beam.
                //  Normally the space below gets occupied, unless there is a splitter in which case n-1 and n+1 get occupied (splitter stays)
                EnvironmentCell::BeamEntry | EnvironmentCell::Occupied=>{
                    if self.space[row+1][col] == EnvironmentCell::Splitter {
                        self.split_count+=1;
                        self.timeline_count+=2; //we divide at this point - 2 timelines
                        if col>0 {
                            self.space[row+1][col-1] = EnvironmentCell::Occupied;
                        } else {
                            //the beam left the diagram, so subtract
                            self.timeline_count-=1;
                        }
                        if col<self.width() {
                            self.space[row+1][col+1] = EnvironmentCell::Occupied;
                        } else {
                            //the beam left the diagram, so subtract
                            self.timeline_count-=1;
                        }
                    } else {
                        self.space[row+1][col] = EnvironmentCell::Occupied;
                    }
                },
                //In these cases the space below remains the same
                EnvironmentCell::Empty=> { },
                EnvironmentCell::Splitter=>{ }
            }
        }

        //println!("{}: input {} output {}", row, String::from_iter(self.space[row].iter().map(|c| c.to_char())), String::from_iter(self.space[row+1].iter().map(|c| c.to_char())));
        Ok( () )
    }

    pub fn count_output_beams(&self) -> usize {
        self.space.last().map(|last_row| {
            last_row.iter().filter(|cell| **cell==EnvironmentCell::Occupied).count()
        }).unwrap_or(0)
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let mut f = File::open("input.txt")?;
    let mut content = String::new();
    f.read_to_string(&mut content)?;
    let mut environment = Environment::from_string(&content)?;

    let steps = content.lines().count()-1;
    for i in 0..steps {
        environment.propagate(i)?;
    }
    println!("The final number of times the beam was split is {}", environment.split_count);
    Ok( () )
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_example_step1() {
        let input = ".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let expected_output = ".......S.......
.......|.......
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let mut environment = Environment::from_string(&input).unwrap();
        environment.propagate(0).expect("propagation failed!");

        assert_eq!(environment.to_string(), expected_output);
    }

        #[test]
    fn test_example_step2() {
        let input = ".......S.......
.......|.......
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let expected_output = ".......S.......
.......|.......
......|^|......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let mut environment = Environment::from_string(&input).unwrap();
        environment.propagate(1).expect("propagation failed!");

        assert_eq!(environment.to_string(), expected_output);
    }

    #[test]
    fn test_example_step3() {
        let input = ".......S.......
.......|.......
......|^|......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let expected_output = ".......S.......
.......|.......
......|^|......
......|.|......
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let mut environment = Environment::from_string(&input).unwrap();
        environment.propagate(2).expect("propagation failed!");

        assert_eq!(environment.to_string(), expected_output);
    }

    #[test]
    fn test_example_full() {
        let input = ".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let expected_output = ".......S.......
.......|.......
......|^|......
......|.|......
.....|^|^|.....
.....|.|.|.....
....|^|^|^|....
....|.|.|.|....
...|^|^|||^|...
...|.|.|||.|...
..|^|^|||^|^|..
..|.|.|||.|.|..
.|^|||^||.||^|.
.|.|||.||.||.|.
|^|^|^|^|^|||^|
|.|.|.|.|.|||.|";

        let steps = input.lines().count()-1;    //we can't propagate the last line as it has nowhere to go

        let mut environment = Environment::from_string(&input).unwrap();

        for i in 0..steps {
            environment.propagate(i).expect("propagation failed!");
        }

        assert_eq!(environment.to_string(), expected_output);
        assert_eq!(environment.split_count, 21);
    }

    #[test]
    fn test_example_part2() {
        let input = ".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............";

        let expected_output = ".......S.......
.......|.......
......|^|......
......|.|......
.....|^|^|.....
.....|.|.|.....
....|^|^|^|....
....|.|.|.|....
...|^|^|||^|...
...|.|.|||.|...
..|^|^|||^|^|..
..|.|.|||.|.|..
.|^|||^||.||^|.
.|.|||.||.||.|.
|^|^|^|^|^|||^|
|.|.|.|.|.|||.|";

        let steps = input.lines().count()-1;    //we can't propagate the last line as it has nowhere to go

        let mut environment = Environment::from_string(&input).unwrap();

        for i in 0..steps {
            environment.propagate(i).expect("propagation failed!");
        }

        assert_eq!(environment.to_string(), expected_output);
        assert_eq!(environment.timeline_count, 40);
    }
}